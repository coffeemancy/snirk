{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"snirk","text":"<p>Snirk is a python wrapper for SNES Interface gRPC API (SNI) providing typed asynchronous interfaces for communicating with SNI-compatible devices (e.g. RetroArch, FxPak Pro).</p> <p>It is intended to be used as a library by other python tools or applications using SNI.</p> <p>Additional details follow:</p> <ul> <li>Usage and examples</li> <li>API docs</li> <li>Development and contribution details</li> </ul>"},{"location":"usage/","title":"Snirk Usage and Examples","text":"<p>This doc demonstrates examples for using the snirk library in an application.</p> <p>The primary means of interaction is through an instance of a <code>Snirk</code> object, which manages interaction to a single SNI device (per instance).</p>"},{"location":"usage/#connecting-to-sni-devices-with-snirk","title":"Connecting to SNI devices with Snirk","text":"<p>Below code snippet instantiates a <code>Snirk</code> object:</p> <pre><code>from snirk import Snirk\n\nsnirk = Snirk()\n</code></pre> <p>Note</p> <p>By default, this uses an SNI server found at <code>localhost:8191</code>. If SNI is running on a different host or port, that channel can be specified at instantiation.</p>"},{"location":"usage/#asyncio-overview","title":"AsyncIO Overview","text":"<p>Snirk uses <code>asyncio</code> for asynchronous communication to SNI devices (e.g. using <code>async</code>/<code>await</code>).</p> <p>This means that most methods on a <code>Snirk</code> object return awaitables (e.g. coroutines), instead of actual results. For example, running <code>.find_device</code> returns a coroutine object:</p> <pre><code>&gt;&gt;&gt; snirk.find_device()\n&lt;coroutine object Snirk.find_device at 0x74dc0c78a6b0&gt;\n</code></pre> <p>This fits well with writing asynchronous applications, but for use in a REPL or synchronous applications (e.g. building CLI tools using Snirk), the <code>asyncio.run</code> method can be used to wait for results (or timeout).</p> <p>Many of the below examples use <code>asyncio.run</code> in this way.</p>"},{"location":"usage/#listing-all-connected-devices","title":"Listing all connected devices","text":"<p>Note</p> <p>In the below examples, two SNI devices are connected (FxPak Pro and Retroarch). Your actual devices will differ depending on device, platform, and random assignment.</p> <p>This object can then be used to list all connected devices (<code>Snirk.list_devices</code>):</p> <pre><code>&gt;&gt;&gt; asyncio.run(snirk.list_devices())\n[uri: \"fxpakpro://./dev/ttyACM4\"\ndisplayName: \"/dev/ttyACM4 (1209:5a22)\"\nkind: \"fxpakpro\"\ncapabilities: ReadMemory\ncapabilities: WriteMemory\ncapabilities: ResetSystem\ncapabilities: ResetToMenu\ncapabilities: ExecuteASM\ncapabilities: FetchFields\ncapabilities: ReadDirectory\ncapabilities: MakeDirectory\ncapabilities: RemoveFile\ncapabilities: RenameFile\ncapabilities: PutFile\ncapabilities: GetFile\ncapabilities: BootFile\n, uri: \"ra://127.0.0.1:55355\"\ndisplayName: \"RetroArch v1.16.0 (127.0.0.1:55355)\"\nkind: \"retroarch\"\ncapabilities: ReadMemory\ncapabilities: WriteMemory\ncapabilities: ResetSystem\ncapabilities: PauseToggleEmulation\ncapabilities: FetchFields\ndefaultAddressSpace: SnesABus\n]\n</code></pre> <p>In the above, details for each device are shown, including the <code>uri</code>, <code>kind</code> (e.g. \"fxpakpro\", \"retroarch\"), and certain capabilities.</p>"},{"location":"usage/#selecting-a-device","title":"Selecting a device","text":"<p>The <code>Snirk.find_device</code> method can be used to find and select a SNI device. The selected device is cached and used for all subsequent operations with the <code>Snirk</code> object.</p> <p>When multiple devices are connected, the selected device is determined by below:</p> <ul> <li>If <code>kind</code> is specified, filter all devices to only select from devices matching that kind (e.g. \"retroarch\")</li> <li>If <code>uri</code> is specified, select the matching device (if it is detected)</li> <li>Otherwise, choose the first matching device (which is not necessarily deterministic)</li> </ul> <p>Extending our example above, where two devices (FxPak Pro and Retroarch) are connected, we specify using one device (the FxPak Pro) with <code>kind</code>:</p> <pre><code>&gt;&gt;&gt; asyncio.run(snirk.find_device(kind=\"fxpakpro\"))\nuri: \"fxpakpro://./dev/ttyACM4\"\ndisplayName: \"/dev/ttyACM4 (1209:5a22)\"\nkind: \"fxpakpro\"\ncapabilities: ReadMemory\ncapabilities: WriteMemory\ncapabilities: ResetSystem\ncapabilities: ResetToMenu\ncapabilities: ExecuteASM\ncapabilities: FetchFields\ncapabilities: ReadDirectory\ncapabilities: MakeDirectory\ncapabilities: RemoveFile\ncapabilities: RenameFile\ncapabilities: PutFile\ncapabilities: GetFile\ncapabilities: BootFile\n</code></pre> <p>Subsequent calls to <code>.find_device</code> will use the value from the cache, unless:</p> <ul> <li>The <code>force</code> parameter is set</li> <li>The <code>kind</code> or <code>uri</code> parameters are used and do not match the currently-cached device</li> </ul> <p>Additionally, the <code>Snirk.device</code> property can be used (it performs <code>asyncio.run</code> itself):</p> <pre><code>&gt;&gt;&gt; snirk.device.uri\n'fxpakpro://./dev/ttyACM4'\n</code></pre> <p>Note</p> <p>The <code>kind</code> or <code>uri</code> cannot be specified on the <code>.device</code> property, so if a device has not already been cached from a previous call to <code>.find_device</code> then it will just use the first device found.</p>"},{"location":"usage/#reading-and-using-memory-data-from-sni-devices","title":"Reading and using memory data from SNI devices","text":""},{"location":"usage/#addressenum-and-memdata","title":"AddressEnum and MemData","text":"<p>The <code>AddressEnum</code> and <code>MemData</code> classes are intended to allow easily translating memory data gRPC responses read over SNI from a game/ROM to named attributes for lookups.</p> <p>In the below snippet, a (partial) mapping of address/size pairs from A Link to the Past Randomizer are mapped to names for easy lookup as an <code>AddressEnum</code>. We also create a <code>MemData</code> class which uses this new <code>AddressEnum</code> type to translate gRPC responses into a <code>dict</code>-like mapping.</p> <pre><code>from snirk.types import AddressEnum\nfrom snirk.types import MemData\n\n\nclass AlttprAddresses(AddressEnum):\n    # current MSU is $010B in WRAM (starts at 0xF50000)\n    # https://github.com/KatDevsGames/z3randomizer/blob/master/msu.asm#L126\n    CURRENT_MSU = (0xF5010B, 0x1)\n\n    # from https://github.com/KrisDavie/DoorTracker/blob/main/DoorsTracker.py\n    DUNGEON = (0xF5040C, 0x1)\n    GAMEMODE = (0xF50010, 0x1)\n    INDOORS = (0xF5001B, 0x1)\n    LAMPCONE = (0xF50458, 0x1)\n\n\nclass AlttprMemData(MemData):\n    memclass = AlttprAddresses\n</code></pre>"},{"location":"usage/#reading-a-single-memory-address","title":"Reading a single memory address","text":"<p>The memory reading functions of <code>Snirk</code> are intended to be passed <code>AddressEnum</code> arguments and return gRPC responses which can be coerced into <code>dict</code> mappings for ease-of-use via <code>MemData</code>.</p> <p>In the below snippet, we use <code>Snirk.single_read</code> with the classes we defined above to read a single memory address and then coerce into a <code>dict</code>:</p> <pre><code>response = asyncio.run(snirk.single_read(AlttprAddresses.GAMEMODE))\nmemdata = AlttprMemData(response)\n</code></pre> <pre><code>&gt;&gt;&gt; response\nuri: \"fxpakpro://./dev/ttyACM3\"\nresponse {\n  requestAddress: 16056336\n  deviceAddress: 16056336\n  data: \"\\007\"\n}\n\n&gt;&gt;&gt; memdata\n{&lt;AlttprAddresses.GAMEMODE: (16056336, 1)&gt;: 7}\n</code></pre>"},{"location":"usage/#reading-multiple-memory-addresses","title":"Reading multiple memory addresses","text":"<p>Below, <code>Snirk.multi_read</code> is used to read multiple addresses in a single request:</p> <pre><code>responses = asyncio.run(snirk.multi_read(*AlttprAddresses))\nmemdata = AlttprMemData(responses)\n</code></pre> <pre><code>&gt;&gt;&gt; responses\nuri: \"fxpakpro://./dev/ttyACM3\"\nresponses {\n  requestAddress: 16056587\n  deviceAddress: 16056587\n  data: \"\\024\"\n}\nresponses {\n  requestAddress: 16057356\n  deviceAddress: 16057356\n  data: \"\\000\"\n}\nresponses {\n  requestAddress: 16056336\n  deviceAddress: 16056336\n  data: \"\\007\"\n}\nresponses {\n  requestAddress: 16056347\n  deviceAddress: 16056347\n  data: \"\\001\"\n}\nresponses {\n  requestAddress: 16057432\n  deviceAddress: 16057432\n  data: \"\\000\"\n}\n\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(memdata)\n{&lt;AlttprAddresses.CURRENT_MSU: (16056587, 1)&gt;: 20,\n &lt;AlttprAddresses.GAMEMODE: (16056336, 1)&gt;: 7,\n &lt;AlttprAddresses.DUNGEON: (16057356, 1)&gt;: 0,\n &lt;AlttprAddresses.INDOORS: (16056347, 1)&gt;: 1,\n &lt;AlttprAddresses.LAMPCONE: (16057432, 1)&gt;: 0}\n</code></pre>"},{"location":"usage/#session-context-manager","title":"Session context manager","text":"<p>In the above examples, we used <code>asyncio.run</code> to resolve awaitables in the python REPL.</p> <p>Alternatively, in async applications, it can be convenient to use a <code>Snirk</code> object in a context manager (similar to sessions in <code>aiohttp</code>), using <code>Snirk.session</code>.</p> <p>The below snippet demonstates this session usage, as well as iterating over multiple SNI devices. This snippet discovers all SNI devices and then reads some memory addresses from each:</p> <pre><code>import asyncio\nimport sys\nfrom pprint import pprint\nfrom snirk import Snirk\nfrom snirk.api import SnirkError\n\nimport examples.snirk_types as st\n\n\nasync def main():\n    # discover all SNI devices\n    try:\n        devices = await Snirk().list_devices()\n    except SnirkError as exc:\n        print(f\"{exc}.\\nIs SNI server running?\")\n        sys.exit(1)\n\n    # handle some requests for each SNI device\n    for device in devices:\n        async with Snirk.session(uri=device.uri) as snirk:\n            print(f\"Device URI: {snirk.device.uri}\")\n            responses = await snirk.multi_read(*st.AlttprAddresses)\n\n        memdata = st.AlttprMemData(responses)\n        pprint(memdata)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Example output:</p> <pre><code>Device URI: fxpakpro://./dev/ttyACM4\n{&lt;AlttprAddresses.DUNGEON: (16057356, 1)&gt;: 85,\n &lt;AlttprAddresses.CURRENT_MSU: (16056587, 1)&gt;: 0,\n &lt;AlttprAddresses.GAMEMODE: (16056336, 1)&gt;: 85,\n &lt;AlttprAddresses.INDOORS: (16056347, 1)&gt;: 85,\n &lt;AlttprAddresses.LAMPCONE: (16057432, 1)&gt;: 85}\nDevice URI: ra://127.0.0.1:55355\n{&lt;AlttprAddresses.DUNGEON: (16057356, 1)&gt;: 255,\n &lt;AlttprAddresses.CURRENT_MSU: (16056587, 1)&gt;: 0,\n &lt;AlttprAddresses.GAMEMODE: (16056336, 1)&gt;: 7,\n &lt;AlttprAddresses.INDOORS: (16056347, 1)&gt;: 1,\n &lt;AlttprAddresses.LAMPCONE: (16057432, 1)&gt;: 0}\n</code></pre>"},{"location":"usage/#accessing-device-filesystems-over-sni","title":"Accessing device filesystems over SNI","text":"<p>Not all SNI devices necessarily have a device filesytem which is accessible. To work with device filesystems over SNI, a separate <code>SnirkFilesystem</code> class is provided (which inherits from <code>Snirk</code>).</p> <p>Note</p> <p>Not all SNI devices necessarily have a device filesytem which is accessible. The <code>SnirkFilesystem</code> methods will only work on devices with appropriate capabilities (which can be seen on the <code>.device</code>). On devices without the appropriate capabilities, a <code>SnirkIncapableError</code> exception will be raised.</p> <p>A <code>SnirkFilesystem</code> instance provides several methods for interacting with device filesystems:</p> <ul> <li><code>SnirkFilesystem.get_file</code></li> <li><code>SnirkFilesystem.put_file</code></li> <li><code>SnirkFilesystem.remove_file</code></li> <li><code>SnirkFilesystem.make_directory</code></li> <li><code>SnirkFilesystem.read_directory</code></li> </ul>"},{"location":"usage/#example","title":"Example","text":"<p>The below example snippet shows connecting to a device filesystem and performing several operations:</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom snirk import SnirkFilesystem\n\n\nasync def main():\n    contents = \"Hello, SNI World.\"\n    example_file = \"/example/hello.txt\"\n    example_dir = str(Path(example_file).parent)\n\n    async with SnirkFilesystem.session(kind=\"fxpakpro\") as snirk:\n        print(f\"* Device URI: {snirk.device.uri}\")\n\n        print(f\"* Making directory: {example_dir}...\")\n        await snirk.make_directory(example_dir)\n\n        print(f\"* Putting file: {example_file}...\")\n        await snirk.put_file(contents.encode(), example_file)\n\n        print(f\"* Reading directory: {example_dir}...\")\n        dirs = await snirk.read_directory(example_dir)\n        print([en.name for en in dirs.entries if en.name not in [\".\", \"..\"]])\n\n        print(f\"* Reading file: {example_file}...\")\n        lines = await snirk.get_file(example_file)\n        print(lines)\n\n        print(f\"* Removing file: {example_file}...\")\n        await snirk.remove_file(example_file)\n\n        print(f\"* Re-reading directory: {example_dir}...\")\n        dirs = await snirk.read_directory(example_dir)\n        print([en.name for en in dirs.entries if en.name not in [\".\", \"..\"]])\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Example output:</p> <pre><code>* Device URI: fxpakpro://./dev/ttyACM0\n* Making directory: /example...\n* Putting file: /example/hello.txt...\n* Reading directory: /example...\n['hello.txt']\n* Reading file: /example/hello.txt...\nuri: \"fxpakpro://./dev/ttyACM0\"\npath: \"/example/hello.txt\"\nsize: 17\ndata: \"Hello, SNI World.\"\n\n* Removing file: /example/hello.txt...\n* Re-reading directory: /example...\n[]\n</code></pre>"},{"location":"api/","title":"Snirk API Docs","text":"<p>These are API docs for the Snirk codebase.</p> <ul> <li><code>snirk.api</code></li> <li><code>snirk.fs</code></li> <li><code>snirk.types</code></li> </ul> <p>Note</p> <p>These are auto-generated from source code docstrings using <code>mkdocstrings</code>.</p>"},{"location":"api/api/","title":"Snirk API Docs :: api","text":""},{"location":"api/api/#snirk.api","title":"snirk.api","text":"<p>Snirk API for connecting to and interacting with SNI devices.</p>"},{"location":"api/api/#snirk.api.Snirk","title":"Snirk  <code>dataclass</code>","text":"<p>Container and API for connecting to and interacting with SNI device.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>str</code> <p>target host/port running SNI server</p> <code>'localhost:8191'</code> Source code in <code>snirk/api.py</code> <pre><code>@dataclass\nclass Snirk:\n    \"\"\"\n    Container and API for connecting to and interacting with SNI device.\n\n    :param channel: target host/port running SNI server\n    \"\"\"\n\n    channel: str = \"localhost:8191\"\n\n    _device: Optional[pb.DevicesResponse.Device] = None\n    _rom_mapping: Optional[pb.MemoryMapping] = None\n\n    @property\n    def device(self) -&gt; pb.DevicesResponse.Device:\n        if self._device is None:\n            self._device = asyncio.run(self.find_device())\n        return self._device\n\n    @device.setter\n    def device(self, uri: str):\n        self._device = asyncio.run(self.find_device(uri=uri))\n\n    async def detect_rom_mapping(self, force: bool = False, timeout: int = 3) -&gt; pb.MemoryMapping:\n        \"\"\"Cached detection of memory mapping from ROM.\n\n        Use lookup from cache unless forced to detect again.\n\n        :param force: when True, force detecting ROM memory mapping, even if cached\n        :param timeout: seconds to attempt detecting ROM memory mapping before timing out\n        :raises SnirkError: cannot detect memory mapping from ROM\n        :return: memory mapping of ROM\n        \"\"\"\n        # unless forced, used cached memory mapping when cached\n        if not force and self._rom_mapping is not None:\n            return self._rom_mapping\n\n        device = await self.find_device()\n\n        async with self.grpc_channel(timeout=timeout) as ch:\n            stub = sni.DeviceMemoryStub(ch)\n            response = stub.MappingDetect(pb.DetectMemoryMappingRequest(uri=device.uri))\n\n        if not response or not (mm := response.memoryMapping):\n            raise SnirkError(\"Could not detect memory mapping from ROM!\")\n\n        self._rom_mapping = mm\n        return mm\n\n    async def ensure_capability(self, capability: pb.DeviceCapability) -&gt; bool:\n        \"\"\"Ensure device has specified capability or raise exception.\n\n        :raises SnirkIncapableError: when device does not have specified capability\n        :returns: True when device has capability\n        \"\"\"\n        device = await self.find_device()\n\n        if capability not in device.capabilities:\n            cap_name = SnirkConstants.CAPABILITY_LOOKUP[capability]\n            raise SnirkIncapableError(f\"Device does not have {cap_name} capability: {device.uri}\")\n        return True\n\n    async def find_device(\n        self, kind: Optional[str] = None, force: bool = False, timeout: int = 10, uri: Optional[str] = None\n    ) -&gt; pb.DevicesResponse.Device:\n        \"\"\"Cached lookup of finding SNI device.\n\n        Use lookup from cache unless forced to detect again.\n        When multiple SNI devices are found, if uri parameter is specified, uses that one. Otherwise uses\n        first device.\n\n        :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n        :param force: when True, force finding SNI device, even if cached\n        :param timeout: seconds to attempt detecting SNI device before timing out\n        :param uri: select device specified by URI\n        :raises SnirkError: cannot find any SNI devices or specified URI\n        :return: SNI device URI string\n        \"\"\"\n        # unless forced, used cached device when cached\n        if not force and self._device is not None:\n            # force if current cached device does not match kind or uri\n            if (not kind or self._device.kind == kind) and (not uri or self._device.uri == uri):\n                return self._device\n\n        devices: list[pb.DevicesResponse.Device] = []\n\n        try:\n            devices = await self.list_devices(kind=kind, timeout=timeout)\n        except asyncio.TimeoutError:\n            pass\n\n        if not devices:\n            if kind:\n                raise SnirkError(f\"Could not find any SNI devices of kind: {kind}\")\n            raise SnirkError(\"Could not find any SNI devices!\")\n\n        if uri:\n            try:\n                device = next(device for device in devices if device.uri == uri)\n            except StopIteration:\n                raise SnirkError(f\"Could not find device specified by URI: {uri}\")\n        else:\n            device = devices[0]\n\n        # cache results for future lookups\n        self._device = device\n        return self._device\n\n    async def list_devices(self, kind: Optional[str] = None, timeout: int = 10) -&gt; list[pb.DevicesResponse.Device]:\n        \"\"\"Get list of all SNI devices or time out.\n\n        :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n        :param timeout: seconds to detect SNI devices before timing out\n        :raises SnirkError: connection refused to gRPC device at target channel\n        :return: list of detected SNI devices\n        \"\"\"\n        devices: list[pb.DevicesResponse.Device] = []\n\n        async with asyncio.timeout(timeout):\n            while True:\n                try:\n                    with grpc.insecure_channel(self.channel) as ch:\n                        stub = sni.DevicesStub(ch)\n                        response = stub.ListDevices(pb.DevicesRequest(kinds=[]))\n                except grpc._channel._InactiveRpcError as exc:\n                    if \"connection refused\" in str(exc).lower():\n                        raise SnirkError(f\"Connection refused: {self.channel}\")\n                    raise\n\n                if response:\n                    # filter devices based on kind, if specified\n                    if kind:\n                        devices = [device for device in response.devices if device.kind == kind]\n                    else:\n                        devices = [device for device in response.devices]\n                    if devices:\n                        break\n\n                timeout = max(0, timeout - 1)\n                await asyncio.sleep(1)\n        return devices\n\n    async def multi_read(self, *addresses: AddressEnum, timeout: int = 3) -&gt; pb.MultiReadMemoryResponse:\n        \"\"\"Read multiple addresses in single request.\n\n        :param addresses: address/size pairs to read\n        :param timeout: timeout for response\n        \"\"\"\n        device = await self.find_device()\n        mm = await self.detect_rom_mapping()\n        requests = [\n            pb.ReadMemoryRequest(requestAddress=address.address, requestMemoryMapping=mm, size=address.size)\n            for address in addresses\n        ]\n\n        async with self.grpc_channel(timeout=timeout) as ch:\n            stub = sni.DeviceMemoryStub(ch)\n            return stub.MultiRead(pb.MultiReadMemoryRequest(uri=device.uri, requests=requests))\n\n    async def single_read(self, address: AddressEnum, timeout: int = 3) -&gt; pb.SingleReadMemoryResponse:\n        \"\"\"Read single address.\n\n        :param address: address/size pair to read\n        :param timeout: timeout for response\n        \"\"\"\n        device = await self.find_device()\n        mm = await self.detect_rom_mapping()\n        request = pb.ReadMemoryRequest(requestAddress=address.address, requestMemoryMapping=mm, size=address.size)\n\n        async with self.grpc_channel(timeout=timeout) as ch:\n            stub = sni.DeviceMemoryStub(ch)\n            return stub.SingleRead(pb.SingleReadMemoryRequest(uri=device.uri, request=request))\n\n    @asynccontextmanager\n    async def grpc_channel(\n        self, options: Optional[list[tuple[str, Any]]] = None, timeout: int = 10\n    ) -&gt; AsyncGenerator[grpc.Channel, None]:\n        \"\"\"Async context manager for gRPC channel with timeout.\n\n        :param options: options to pass to creating gRPC channel\n        :param timeout: seconds until timeout\n        :yields: grpc channel\n        \"\"\"\n        async with asyncio.timeout(timeout):\n            with grpc.insecure_channel(self.channel, options=options) as channel:\n                yield channel\n\n    @classmethod\n    @asynccontextmanager\n    async def session(cls, kind: Optional[str] = None, uri: Optional[str] = None) -&gt; AsyncGenerator[\"Snirk\", None]:\n        \"\"\"Async context manager for SNI session.\n\n        :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n        :param uri: select device specified by URI\n        \"\"\"\n        snirk = cls()\n        await snirk.find_device(kind=kind, uri=uri)\n        yield snirk\n\n    @staticmethod\n    async def retry_grpc(\n        fn: Callable[..., Any],\n        backoff: bool = True,\n        max_retries: Optional[int] = None,\n        sleep: float = 0.1,\n        timeout: int = 10,\n    ):\n        \"\"\"Decorator for gRPC function with base-2 exponential backoff, max retries, and timeout.\n\n        :param backoff: when True, double sleep between each retry\n        :param max_retries: maximum amount of retries to try (default: -1, unlimited retries until timeout)\n        :param sleep: seconds between retries (initial when backoff is used)\n        :param timeout: seconds until timeout\n        \"\"\"\n\n        @wraps(fn)\n        async def wrapper(*args, **kwargs):\n            retries = 0\n            sleep_time = sleep\n            async with asyncio.timeout(timeout):\n                while max_retries is None or retries &lt; max_retries:\n                    try:\n                        return fn(*args, **kwargs)\n                    except grpc._channel._InactiveRpcError as exc:\n                        if \"does not contain USBA header\" not in str(exc):\n                            raise\n                    await asyncio.sleep(sleep_time)\n                    if backoff:\n                        sleep_time *= 2\n                    retries += 1\n\n        return wrapper\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.detect_rom_mapping","title":"detect_rom_mapping  <code>async</code>","text":"<pre><code>detect_rom_mapping(force=False, timeout=3)\n</code></pre> <p>Cached detection of memory mapping from ROM.</p> <p>Use lookup from cache unless forced to detect again.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>when True, force detecting ROM memory mapping, even if cached</p> <code>False</code> <code>timeout</code> <code>int</code> <p>seconds to attempt detecting ROM memory mapping before timing out</p> <code>3</code> <p>Returns:</p> Type Description <code>MemoryMapping</code> <p>memory mapping of ROM</p> <p>Raises:</p> Type Description <code>SnirkError</code> <p>cannot detect memory mapping from ROM</p> Source code in <code>snirk/api.py</code> <pre><code>async def detect_rom_mapping(self, force: bool = False, timeout: int = 3) -&gt; pb.MemoryMapping:\n    \"\"\"Cached detection of memory mapping from ROM.\n\n    Use lookup from cache unless forced to detect again.\n\n    :param force: when True, force detecting ROM memory mapping, even if cached\n    :param timeout: seconds to attempt detecting ROM memory mapping before timing out\n    :raises SnirkError: cannot detect memory mapping from ROM\n    :return: memory mapping of ROM\n    \"\"\"\n    # unless forced, used cached memory mapping when cached\n    if not force and self._rom_mapping is not None:\n        return self._rom_mapping\n\n    device = await self.find_device()\n\n    async with self.grpc_channel(timeout=timeout) as ch:\n        stub = sni.DeviceMemoryStub(ch)\n        response = stub.MappingDetect(pb.DetectMemoryMappingRequest(uri=device.uri))\n\n    if not response or not (mm := response.memoryMapping):\n        raise SnirkError(\"Could not detect memory mapping from ROM!\")\n\n    self._rom_mapping = mm\n    return mm\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.ensure_capability","title":"ensure_capability  <code>async</code>","text":"<pre><code>ensure_capability(capability)\n</code></pre> <p>Ensure device has specified capability or raise exception.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True when device has capability</p> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have specified capability</p> Source code in <code>snirk/api.py</code> <pre><code>async def ensure_capability(self, capability: pb.DeviceCapability) -&gt; bool:\n    \"\"\"Ensure device has specified capability or raise exception.\n\n    :raises SnirkIncapableError: when device does not have specified capability\n    :returns: True when device has capability\n    \"\"\"\n    device = await self.find_device()\n\n    if capability not in device.capabilities:\n        cap_name = SnirkConstants.CAPABILITY_LOOKUP[capability]\n        raise SnirkIncapableError(f\"Device does not have {cap_name} capability: {device.uri}\")\n    return True\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.find_device","title":"find_device  <code>async</code>","text":"<pre><code>find_device(kind=None, force=False, timeout=10, uri=None)\n</code></pre> <p>Cached lookup of finding SNI device.</p> <p>Use lookup from cache unless forced to detect again. When multiple SNI devices are found, if uri parameter is specified, uses that one. Otherwise uses first device.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Optional[str]</code> <p>limit devices to specified kind (e.g. \"fxpakpro\")</p> <code>None</code> <code>force</code> <code>bool</code> <p>when True, force finding SNI device, even if cached</p> <code>False</code> <code>timeout</code> <code>int</code> <p>seconds to attempt detecting SNI device before timing out</p> <code>10</code> <code>uri</code> <code>Optional[str]</code> <p>select device specified by URI</p> <code>None</code> <p>Returns:</p> Type Description <code>Device</code> <p>SNI device URI string</p> <p>Raises:</p> Type Description <code>SnirkError</code> <p>cannot find any SNI devices or specified URI</p> Source code in <code>snirk/api.py</code> <pre><code>async def find_device(\n    self, kind: Optional[str] = None, force: bool = False, timeout: int = 10, uri: Optional[str] = None\n) -&gt; pb.DevicesResponse.Device:\n    \"\"\"Cached lookup of finding SNI device.\n\n    Use lookup from cache unless forced to detect again.\n    When multiple SNI devices are found, if uri parameter is specified, uses that one. Otherwise uses\n    first device.\n\n    :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n    :param force: when True, force finding SNI device, even if cached\n    :param timeout: seconds to attempt detecting SNI device before timing out\n    :param uri: select device specified by URI\n    :raises SnirkError: cannot find any SNI devices or specified URI\n    :return: SNI device URI string\n    \"\"\"\n    # unless forced, used cached device when cached\n    if not force and self._device is not None:\n        # force if current cached device does not match kind or uri\n        if (not kind or self._device.kind == kind) and (not uri or self._device.uri == uri):\n            return self._device\n\n    devices: list[pb.DevicesResponse.Device] = []\n\n    try:\n        devices = await self.list_devices(kind=kind, timeout=timeout)\n    except asyncio.TimeoutError:\n        pass\n\n    if not devices:\n        if kind:\n            raise SnirkError(f\"Could not find any SNI devices of kind: {kind}\")\n        raise SnirkError(\"Could not find any SNI devices!\")\n\n    if uri:\n        try:\n            device = next(device for device in devices if device.uri == uri)\n        except StopIteration:\n            raise SnirkError(f\"Could not find device specified by URI: {uri}\")\n    else:\n        device = devices[0]\n\n    # cache results for future lookups\n    self._device = device\n    return self._device\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.grpc_channel","title":"grpc_channel  <code>async</code>","text":"<pre><code>grpc_channel(options=None, timeout=10)\n</code></pre> <p>Async context manager for gRPC channel with timeout.</p> <p>:yields: grpc channel</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Optional[list[tuple[str, Any]]]</code> <p>options to pass to creating gRPC channel</p> <code>None</code> <code>timeout</code> <code>int</code> <p>seconds until timeout</p> <code>10</code> Source code in <code>snirk/api.py</code> <pre><code>@asynccontextmanager\nasync def grpc_channel(\n    self, options: Optional[list[tuple[str, Any]]] = None, timeout: int = 10\n) -&gt; AsyncGenerator[grpc.Channel, None]:\n    \"\"\"Async context manager for gRPC channel with timeout.\n\n    :param options: options to pass to creating gRPC channel\n    :param timeout: seconds until timeout\n    :yields: grpc channel\n    \"\"\"\n    async with asyncio.timeout(timeout):\n        with grpc.insecure_channel(self.channel, options=options) as channel:\n            yield channel\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.list_devices","title":"list_devices  <code>async</code>","text":"<pre><code>list_devices(kind=None, timeout=10)\n</code></pre> <p>Get list of all SNI devices or time out.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Optional[str]</code> <p>limit devices to specified kind (e.g. \"fxpakpro\")</p> <code>None</code> <code>timeout</code> <code>int</code> <p>seconds to detect SNI devices before timing out</p> <code>10</code> <p>Returns:</p> Type Description <code>list[Device]</code> <p>list of detected SNI devices</p> <p>Raises:</p> Type Description <code>SnirkError</code> <p>connection refused to gRPC device at target channel</p> Source code in <code>snirk/api.py</code> <pre><code>async def list_devices(self, kind: Optional[str] = None, timeout: int = 10) -&gt; list[pb.DevicesResponse.Device]:\n    \"\"\"Get list of all SNI devices or time out.\n\n    :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n    :param timeout: seconds to detect SNI devices before timing out\n    :raises SnirkError: connection refused to gRPC device at target channel\n    :return: list of detected SNI devices\n    \"\"\"\n    devices: list[pb.DevicesResponse.Device] = []\n\n    async with asyncio.timeout(timeout):\n        while True:\n            try:\n                with grpc.insecure_channel(self.channel) as ch:\n                    stub = sni.DevicesStub(ch)\n                    response = stub.ListDevices(pb.DevicesRequest(kinds=[]))\n            except grpc._channel._InactiveRpcError as exc:\n                if \"connection refused\" in str(exc).lower():\n                    raise SnirkError(f\"Connection refused: {self.channel}\")\n                raise\n\n            if response:\n                # filter devices based on kind, if specified\n                if kind:\n                    devices = [device for device in response.devices if device.kind == kind]\n                else:\n                    devices = [device for device in response.devices]\n                if devices:\n                    break\n\n            timeout = max(0, timeout - 1)\n            await asyncio.sleep(1)\n    return devices\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.multi_read","title":"multi_read  <code>async</code>","text":"<pre><code>multi_read(*addresses, timeout=3)\n</code></pre> <p>Read multiple addresses in single request.</p> <p>Parameters:</p> Name Type Description Default <code>addresses</code> <code>AddressEnum</code> <p>address/size pairs to read</p> <code>()</code> <code>timeout</code> <code>int</code> <p>timeout for response</p> <code>3</code> Source code in <code>snirk/api.py</code> <pre><code>async def multi_read(self, *addresses: AddressEnum, timeout: int = 3) -&gt; pb.MultiReadMemoryResponse:\n    \"\"\"Read multiple addresses in single request.\n\n    :param addresses: address/size pairs to read\n    :param timeout: timeout for response\n    \"\"\"\n    device = await self.find_device()\n    mm = await self.detect_rom_mapping()\n    requests = [\n        pb.ReadMemoryRequest(requestAddress=address.address, requestMemoryMapping=mm, size=address.size)\n        for address in addresses\n    ]\n\n    async with self.grpc_channel(timeout=timeout) as ch:\n        stub = sni.DeviceMemoryStub(ch)\n        return stub.MultiRead(pb.MultiReadMemoryRequest(uri=device.uri, requests=requests))\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.retry_grpc","title":"retry_grpc  <code>async</code> <code>staticmethod</code>","text":"<pre><code>retry_grpc(fn, backoff=True, max_retries=None, sleep=0.1, timeout=10)\n</code></pre> <p>Decorator for gRPC function with base-2 exponential backoff, max retries, and timeout.</p> <p>Parameters:</p> Name Type Description Default <code>backoff</code> <code>bool</code> <p>when True, double sleep between each retry</p> <code>True</code> <code>max_retries</code> <code>Optional[int]</code> <p>maximum amount of retries to try (default: -1, unlimited retries until timeout)</p> <code>None</code> <code>sleep</code> <code>float</code> <p>seconds between retries (initial when backoff is used)</p> <code>0.1</code> <code>timeout</code> <code>int</code> <p>seconds until timeout</p> <code>10</code> Source code in <code>snirk/api.py</code> <pre><code>@staticmethod\nasync def retry_grpc(\n    fn: Callable[..., Any],\n    backoff: bool = True,\n    max_retries: Optional[int] = None,\n    sleep: float = 0.1,\n    timeout: int = 10,\n):\n    \"\"\"Decorator for gRPC function with base-2 exponential backoff, max retries, and timeout.\n\n    :param backoff: when True, double sleep between each retry\n    :param max_retries: maximum amount of retries to try (default: -1, unlimited retries until timeout)\n    :param sleep: seconds between retries (initial when backoff is used)\n    :param timeout: seconds until timeout\n    \"\"\"\n\n    @wraps(fn)\n    async def wrapper(*args, **kwargs):\n        retries = 0\n        sleep_time = sleep\n        async with asyncio.timeout(timeout):\n            while max_retries is None or retries &lt; max_retries:\n                try:\n                    return fn(*args, **kwargs)\n                except grpc._channel._InactiveRpcError as exc:\n                    if \"does not contain USBA header\" not in str(exc):\n                        raise\n                await asyncio.sleep(sleep_time)\n                if backoff:\n                    sleep_time *= 2\n                retries += 1\n\n    return wrapper\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.session","title":"session  <code>async</code> <code>classmethod</code>","text":"<pre><code>session(kind=None, uri=None)\n</code></pre> <p>Async context manager for SNI session.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>Optional[str]</code> <p>limit devices to specified kind (e.g. \"fxpakpro\")</p> <code>None</code> <code>uri</code> <code>Optional[str]</code> <p>select device specified by URI</p> <code>None</code> Source code in <code>snirk/api.py</code> <pre><code>@classmethod\n@asynccontextmanager\nasync def session(cls, kind: Optional[str] = None, uri: Optional[str] = None) -&gt; AsyncGenerator[\"Snirk\", None]:\n    \"\"\"Async context manager for SNI session.\n\n    :param kind: limit devices to specified kind (e.g. \"fxpakpro\")\n    :param uri: select device specified by URI\n    \"\"\"\n    snirk = cls()\n    await snirk.find_device(kind=kind, uri=uri)\n    yield snirk\n</code></pre>"},{"location":"api/api/#snirk.api.Snirk.single_read","title":"single_read  <code>async</code>","text":"<pre><code>single_read(address, timeout=3)\n</code></pre> <p>Read single address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>AddressEnum</code> <p>address/size pair to read</p> required <code>timeout</code> <code>int</code> <p>timeout for response</p> <code>3</code> Source code in <code>snirk/api.py</code> <pre><code>async def single_read(self, address: AddressEnum, timeout: int = 3) -&gt; pb.SingleReadMemoryResponse:\n    \"\"\"Read single address.\n\n    :param address: address/size pair to read\n    :param timeout: timeout for response\n    \"\"\"\n    device = await self.find_device()\n    mm = await self.detect_rom_mapping()\n    request = pb.ReadMemoryRequest(requestAddress=address.address, requestMemoryMapping=mm, size=address.size)\n\n    async with self.grpc_channel(timeout=timeout) as ch:\n        stub = sni.DeviceMemoryStub(ch)\n        return stub.SingleRead(pb.SingleReadMemoryRequest(uri=device.uri, request=request))\n</code></pre>"},{"location":"api/api/#snirk.api.SnirkIncapableError","title":"SnirkIncapableError","text":"<p>             Bases: <code>BaseException</code></p> <p>Exception raised when SNI device does not have needed capability.</p> Source code in <code>snirk/api.py</code> <pre><code>class SnirkIncapableError(BaseException):\n    \"\"\"Exception raised when SNI device does not have needed capability.\"\"\"\n</code></pre>"},{"location":"api/fs/","title":"Snirk API Docs :: fs","text":""},{"location":"api/fs/#snirk.fs","title":"snirk.fs","text":"<p>Snirk API for connecting to and interacting with SNI device filesystems.</p>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem","title":"SnirkFilesystem","text":"<p>             Bases: <code>Snirk</code></p> <p>Container and API for connecting to and interacting with SNI devices with access to device filesystem.</p> <p>Each operation assures that the SNI device has necessary capabilities before attempting to access the device filesystem, raising a SnirkIncapableError exception when the capabilities are missing.</p> <p>Parameters:</p> Name Type Description Default <code>max_message_length</code> <code>int</code> <p>max bytes to transfer in get/put operations</p> required Source code in <code>snirk/fs.py</code> <pre><code>class SnirkFilesystem(Snirk):\n    \"\"\"\n    Container and API for connecting to and interacting with SNI devices with access to device filesystem.\n\n    Each operation assures that the SNI device has necessary capabilities before attempting to access\n    the device filesystem, raising a SnirkIncapableError exception when the capabilities are missing.\n\n    :param max_message_length: max bytes to transfer in get/put operations\n    :type max_message_length: int\n    \"\"\"\n\n    max_message_length: int = 1024**3\n\n    async def get_file(self, device_file: str, timeout: int = 30) -&gt; pb.GetFileResponse:\n        \"\"\"Get device file from SNI device filesystem.\n\n        :param device_file: path to device file to read\n        :param timeout: seconds until timeout reading file from device\n        :raises SnirkIncapableError: when device does not have GetFile capability\n        \"\"\"\n        device = await self.find_device()\n        await self.ensure_capability(pb.DeviceCapability.GetFile)\n\n        options = [\n            (\"grpc.max_message_length\", self.max_message_length),\n            (\"grpc.max_receive_message_length\", self.max_message_length),\n        ]\n        async with self.grpc_channel(options=options, timeout=timeout) as ch:\n            stub = sni.DeviceFilesystemStub(ch)\n            retry_get = await self.retry_grpc(stub.GetFile, max_retries=3, sleep=0.5)\n            return await retry_get(pb.GetFileRequest(uri=device.uri, path=device_file))\n\n    async def make_directory(self, device_path: str, parents: bool = False, timeout: int = 10):\n        \"\"\"Create missing directories on SNI device filesystem.\n\n        If parents is not true, then an exception will propagate from gRPC if device_path\n        cannot be created because it's parent (sub-)directories do not exist. When parents is\n        true, all missing (sub-)directories will be created in the correct order.\n\n        :param device_path: path to create on SNI device\n        :param parents: when True, create any missing parent (sub-)directories for device_path\n        :param timeout: seconds to try creating directories until timeout\n        :raises SnirkIncapableError: when device does not have MakeDirectory capability\n        \"\"\"\n        directories: list[str] = [device_path]\n        if parents:\n            parts = Path(device_path).parts\n            directories = [str(Path(*parts[0:x])) for x in range(2, len(parts) + 1)]\n\n        device = await self.find_device()\n        await self.ensure_capability(pb.DeviceCapability.MakeDirectory)\n\n        # find and create missing directories\n        async with self.grpc_channel(timeout=timeout) as ch:\n            stub = sni.DeviceFilesystemStub(ch)\n            for directory in directories:\n                try:\n                    stub.ReadDirectory(pb.ReadDirectoryRequest(uri=device.uri, path=directory))\n                except grpc._channel._InactiveRpcError:\n                    retry_mkdir = await self.retry_grpc(stub.MakeDirectory)\n                    await retry_mkdir(pb.MakeDirectoryRequest(uri=device.uri, path=directory))\n\n    async def put_file(self, data: bytes, device_path: str, timeout: int = 30) -&gt; pb.PutFileResponse:\n        \"\"\"Put file bytes at path on SNI device filesystem.\n\n        :param data: bytes to write to device path\n        :param device_path: path on device to write local_file bytes\n        :param timeout: seconds until timeout writing file to device\n        :raises SnirkIncapableError: when device does not have PutFile capability\n        \"\"\"\n        device = await self.find_device()\n        await self.ensure_capability(pb.DeviceCapability.PutFile)\n\n        options = [\n            (\"grpc.max_message_length\", self.max_message_length),\n            (\"grpc.max_send_message_length\", self.max_message_length),\n        ]\n        async with self.grpc_channel(options=options, timeout=timeout) as ch:\n            stub = sni.DeviceFilesystemStub(ch)\n            retry_put = await self.retry_grpc(stub.PutFile, max_retries=3, sleep=0.5)\n            response = await retry_put(pb.PutFileRequest(uri=device.uri, path=device_path, data=data))\n\n        # note: appears that PutFileResponse.size is missing\n        # might be SNI bug or could be gRPC proto error (it specifies size)\n        return response\n\n    async def read_directory(self, path: str, timeout: int = 2) -&gt; pb.ReadDirectoryResponse:\n        \"\"\"Read directory from SNI device filesystem.\n\n        :param path: directory path to read from device\n        :param timeout: seconds until timeout reading directory from device\n        :raises SnirkIncapableError: when device does not have ReadDirectory capability\n        \"\"\"\n        device = await self.find_device()\n        await self.ensure_capability(pb.DeviceCapability.ReadDirectory)\n\n        async with self.grpc_channel() as ch:\n            stub = sni.DeviceFilesystemStub(ch)\n            retry = await self.retry_grpc(stub.ReadDirectory, timeout=timeout)\n            try:\n                response = await retry(pb.ReadDirectoryRequest(uri=device.uri, path=path))\n            except grpc._channel._InactiveRpcError as ex:\n                if \"failed to list\" not in str(ex):\n                    raise\n                # otherwise, could be because path is a single file, or because doesn't exist\n                # if doesn't exist, let exception propagate up\n                parent = str(Path(path).parent)\n                response = await retry(pb.ReadDirectoryRequest(uri=device.uri, path=parent))\n        return response\n\n    async def remove_file(self, device_file: str, timeout: int = 5) -&gt; pb.RemoveFileResponse:\n        \"\"\"Remove device file from SNI device filesystem.\n\n        :param device_file: path to device file to remove\n        :param timeout: seconds until timeout removing file from device\n        :raises SnirkIncapableError: when device does not have RemoveFile capability\n        \"\"\"\n        device = await self.find_device()\n        await self.ensure_capability(pb.DeviceCapability.RemoveFile)\n\n        async with self.grpc_channel(timeout=timeout) as ch:\n            stub = sni.DeviceFilesystemStub(ch)\n            retry_get = await self.retry_grpc(stub.RemoveFile, max_retries=3, sleep=0.5)\n            return await retry_get(pb.RemoveFileRequest(uri=device.uri, path=device_file))\n</code></pre>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem.get_file","title":"get_file  <code>async</code>","text":"<pre><code>get_file(device_file, timeout=30)\n</code></pre> <p>Get device file from SNI device filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>device_file</code> <code>str</code> <p>path to device file to read</p> required <code>timeout</code> <code>int</code> <p>seconds until timeout reading file from device</p> <code>30</code> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have GetFile capability</p> Source code in <code>snirk/fs.py</code> <pre><code>async def get_file(self, device_file: str, timeout: int = 30) -&gt; pb.GetFileResponse:\n    \"\"\"Get device file from SNI device filesystem.\n\n    :param device_file: path to device file to read\n    :param timeout: seconds until timeout reading file from device\n    :raises SnirkIncapableError: when device does not have GetFile capability\n    \"\"\"\n    device = await self.find_device()\n    await self.ensure_capability(pb.DeviceCapability.GetFile)\n\n    options = [\n        (\"grpc.max_message_length\", self.max_message_length),\n        (\"grpc.max_receive_message_length\", self.max_message_length),\n    ]\n    async with self.grpc_channel(options=options, timeout=timeout) as ch:\n        stub = sni.DeviceFilesystemStub(ch)\n        retry_get = await self.retry_grpc(stub.GetFile, max_retries=3, sleep=0.5)\n        return await retry_get(pb.GetFileRequest(uri=device.uri, path=device_file))\n</code></pre>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem.make_directory","title":"make_directory  <code>async</code>","text":"<pre><code>make_directory(device_path, parents=False, timeout=10)\n</code></pre> <p>Create missing directories on SNI device filesystem.</p> <p>If parents is not true, then an exception will propagate from gRPC if device_path cannot be created because it's parent (sub-)directories do not exist. When parents is true, all missing (sub-)directories will be created in the correct order.</p> <p>Parameters:</p> Name Type Description Default <code>device_path</code> <code>str</code> <p>path to create on SNI device</p> required <code>parents</code> <code>bool</code> <p>when True, create any missing parent (sub-)directories for device_path</p> <code>False</code> <code>timeout</code> <code>int</code> <p>seconds to try creating directories until timeout</p> <code>10</code> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have MakeDirectory capability</p> Source code in <code>snirk/fs.py</code> <pre><code>async def make_directory(self, device_path: str, parents: bool = False, timeout: int = 10):\n    \"\"\"Create missing directories on SNI device filesystem.\n\n    If parents is not true, then an exception will propagate from gRPC if device_path\n    cannot be created because it's parent (sub-)directories do not exist. When parents is\n    true, all missing (sub-)directories will be created in the correct order.\n\n    :param device_path: path to create on SNI device\n    :param parents: when True, create any missing parent (sub-)directories for device_path\n    :param timeout: seconds to try creating directories until timeout\n    :raises SnirkIncapableError: when device does not have MakeDirectory capability\n    \"\"\"\n    directories: list[str] = [device_path]\n    if parents:\n        parts = Path(device_path).parts\n        directories = [str(Path(*parts[0:x])) for x in range(2, len(parts) + 1)]\n\n    device = await self.find_device()\n    await self.ensure_capability(pb.DeviceCapability.MakeDirectory)\n\n    # find and create missing directories\n    async with self.grpc_channel(timeout=timeout) as ch:\n        stub = sni.DeviceFilesystemStub(ch)\n        for directory in directories:\n            try:\n                stub.ReadDirectory(pb.ReadDirectoryRequest(uri=device.uri, path=directory))\n            except grpc._channel._InactiveRpcError:\n                retry_mkdir = await self.retry_grpc(stub.MakeDirectory)\n                await retry_mkdir(pb.MakeDirectoryRequest(uri=device.uri, path=directory))\n</code></pre>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem.put_file","title":"put_file  <code>async</code>","text":"<pre><code>put_file(data, device_path, timeout=30)\n</code></pre> <p>Put file bytes at path on SNI device filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>bytes to write to device path</p> required <code>device_path</code> <code>str</code> <p>path on device to write local_file bytes</p> required <code>timeout</code> <code>int</code> <p>seconds until timeout writing file to device</p> <code>30</code> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have PutFile capability</p> Source code in <code>snirk/fs.py</code> <pre><code>async def put_file(self, data: bytes, device_path: str, timeout: int = 30) -&gt; pb.PutFileResponse:\n    \"\"\"Put file bytes at path on SNI device filesystem.\n\n    :param data: bytes to write to device path\n    :param device_path: path on device to write local_file bytes\n    :param timeout: seconds until timeout writing file to device\n    :raises SnirkIncapableError: when device does not have PutFile capability\n    \"\"\"\n    device = await self.find_device()\n    await self.ensure_capability(pb.DeviceCapability.PutFile)\n\n    options = [\n        (\"grpc.max_message_length\", self.max_message_length),\n        (\"grpc.max_send_message_length\", self.max_message_length),\n    ]\n    async with self.grpc_channel(options=options, timeout=timeout) as ch:\n        stub = sni.DeviceFilesystemStub(ch)\n        retry_put = await self.retry_grpc(stub.PutFile, max_retries=3, sleep=0.5)\n        response = await retry_put(pb.PutFileRequest(uri=device.uri, path=device_path, data=data))\n\n    # note: appears that PutFileResponse.size is missing\n    # might be SNI bug or could be gRPC proto error (it specifies size)\n    return response\n</code></pre>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem.read_directory","title":"read_directory  <code>async</code>","text":"<pre><code>read_directory(path, timeout=2)\n</code></pre> <p>Read directory from SNI device filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>directory path to read from device</p> required <code>timeout</code> <code>int</code> <p>seconds until timeout reading directory from device</p> <code>2</code> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have ReadDirectory capability</p> Source code in <code>snirk/fs.py</code> <pre><code>async def read_directory(self, path: str, timeout: int = 2) -&gt; pb.ReadDirectoryResponse:\n    \"\"\"Read directory from SNI device filesystem.\n\n    :param path: directory path to read from device\n    :param timeout: seconds until timeout reading directory from device\n    :raises SnirkIncapableError: when device does not have ReadDirectory capability\n    \"\"\"\n    device = await self.find_device()\n    await self.ensure_capability(pb.DeviceCapability.ReadDirectory)\n\n    async with self.grpc_channel() as ch:\n        stub = sni.DeviceFilesystemStub(ch)\n        retry = await self.retry_grpc(stub.ReadDirectory, timeout=timeout)\n        try:\n            response = await retry(pb.ReadDirectoryRequest(uri=device.uri, path=path))\n        except grpc._channel._InactiveRpcError as ex:\n            if \"failed to list\" not in str(ex):\n                raise\n            # otherwise, could be because path is a single file, or because doesn't exist\n            # if doesn't exist, let exception propagate up\n            parent = str(Path(path).parent)\n            response = await retry(pb.ReadDirectoryRequest(uri=device.uri, path=parent))\n    return response\n</code></pre>"},{"location":"api/fs/#snirk.fs.SnirkFilesystem.remove_file","title":"remove_file  <code>async</code>","text":"<pre><code>remove_file(device_file, timeout=5)\n</code></pre> <p>Remove device file from SNI device filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>device_file</code> <code>str</code> <p>path to device file to remove</p> required <code>timeout</code> <code>int</code> <p>seconds until timeout removing file from device</p> <code>5</code> <p>Raises:</p> Type Description <code>SnirkIncapableError</code> <p>when device does not have RemoveFile capability</p> Source code in <code>snirk/fs.py</code> <pre><code>async def remove_file(self, device_file: str, timeout: int = 5) -&gt; pb.RemoveFileResponse:\n    \"\"\"Remove device file from SNI device filesystem.\n\n    :param device_file: path to device file to remove\n    :param timeout: seconds until timeout removing file from device\n    :raises SnirkIncapableError: when device does not have RemoveFile capability\n    \"\"\"\n    device = await self.find_device()\n    await self.ensure_capability(pb.DeviceCapability.RemoveFile)\n\n    async with self.grpc_channel(timeout=timeout) as ch:\n        stub = sni.DeviceFilesystemStub(ch)\n        retry_get = await self.retry_grpc(stub.RemoveFile, max_retries=3, sleep=0.5)\n        return await retry_get(pb.RemoveFileRequest(uri=device.uri, path=device_file))\n</code></pre>"},{"location":"api/types/","title":"Snirk API Docs :: types","text":""},{"location":"api/types/#snirk.types","title":"snirk.types","text":""},{"location":"api/types/#snirk.types.AddressEnum","title":"AddressEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Enum of address keys mapped to address and size.</p> <p>Supports getting via attribute (per typical enum) as well as getting via string key.</p> Source code in <code>snirk/types.py</code> <pre><code>class AddressEnum(Enum):\n    \"\"\"Enum of address keys mapped to address and size.\n\n    Supports getting via attribute (per typical enum) as well as getting via string key.\n    \"\"\"\n\n    def __init__(self, address: int, size: int):\n        self.address = address\n        self.size = size\n\n    @classmethod\n    def get(cls, address: int):\n        \"\"\"Lookup by address.\"\"\"\n        return next(member for member in cls if member.address == address)\n</code></pre>"},{"location":"api/types/#snirk.types.AddressEnum.get","title":"get  <code>classmethod</code>","text":"<pre><code>get(address)\n</code></pre> <p>Lookup by address.</p> Source code in <code>snirk/types.py</code> <pre><code>@classmethod\ndef get(cls, address: int):\n    \"\"\"Lookup by address.\"\"\"\n    return next(member for member in cls if member.address == address)\n</code></pre>"},{"location":"api/types/#snirk.types.MemData","title":"MemData","text":"<p>             Bases: <code>UserDict</code></p> <p>Dict-like container for mapping of memory addresses to values parsed from gRPC response.</p> <p>Intended to be subclassed by apps using Snirk with a relevant AddressEnum subclass.</p> <p>Allows lookup via indexing (\"[...]\") from: address enum (AddressEnum), memory address (int), or key (str). Preferred method is generally by AddressEnum for static use so mypy/type-checker can catch, instead of runtime errors (where possible).</p> <p>Parameters:</p> Name Type Description Default <code>memclass</code> <code>Type[AddressEnum]</code> <p>AddressEnum subclass associated with this MemData subclass</p> required Source code in <code>snirk/types.py</code> <pre><code>class MemData(UserDict):\n    \"\"\"Dict-like container for mapping of memory addresses to values parsed from gRPC response.\n\n    Intended to be subclassed by apps using Snirk with a relevant AddressEnum subclass.\n\n    Allows lookup via indexing (\"[...]\") from: address enum (AddressEnum), memory address (int), or key (str).\n    Preferred method is generally by AddressEnum for static use so mypy/type-checker can catch, instead of\n    runtime errors (where possible).\n\n    :param memclass: AddressEnum subclass associated with this MemData subclass\n    :type memclass: Type[AddressEnum]\n    \"\"\"\n\n    # set in subclasses to a particular AddressEnum subclass\n    memclass: ClassVar[Type[AddressEnum]]\n\n    def __init__(self, response: Optional[Union[pb.MultiReadMemoryResponse, pb.SingleReadMemoryResponse]] = None):\n        \"\"\"Initialize memory data with optional parsing of gRPC response into data.\n\n        :param response: SNI multi read memory response to parse\n        \"\"\"\n        self.data: dict[AddressEnum, int] = {}\n\n        if response:\n            self.parse(response)\n\n    def __getitem__(self, key: Union[AddressEnum, int, str]) -&gt; int:\n        \"\"\"Lookup memory data via key.\n\n        Try to lookup via key directly (e.g. AddressEnum). On KeyError, if int, perform lookup via address.\n        When string, lookup via AddressEnum (using string). Otherwise, raise a KeyError.\n\n        :param key: key to lookup from data\n        :raises KeyError: cannot find key in data\n        \"\"\"\n        if isinstance(key, int):\n            return self.data[self.memclass.get(key)]\n        elif isinstance(key, str):\n            return self.data[self.memclass[key]]\n        return self.data[key]\n\n    @singledispatchmethod\n    def parse(self, response):\n        \"\"\"Parse gRPC response into data.\n\n        :param response: SNI single/multi read memory response to parse\n        :type response: Union[pb.MultiReadMemoryResponse, pb.SingleReadMemoryResponse]\n        \"\"\"\n        raise NotImplementedError(f\"Cannot parse response: {response}\")\n\n    @parse.register\n    def _(self, response: pb.MultiReadMemoryResponse):\n        self.data = {self.memclass.get(msg.requestAddress): int(msg.data.hex(), 16) for msg in response.responses}\n\n    @parse.register\n    def _(self, response: pb.SingleReadMemoryResponse):\n        msg = response.response\n        self.data = {self.memclass.get(msg.requestAddress): int(msg.data.hex(), 16)}\n</code></pre>"},{"location":"api/types/#snirk.types.MemData.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Lookup memory data via key.</p> <p>Try to lookup via key directly (e.g. AddressEnum). On KeyError, if int, perform lookup via address. When string, lookup via AddressEnum (using string). Otherwise, raise a KeyError.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Union[AddressEnum, int, str]</code> <p>key to lookup from data</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>cannot find key in data</p> Source code in <code>snirk/types.py</code> <pre><code>def __getitem__(self, key: Union[AddressEnum, int, str]) -&gt; int:\n    \"\"\"Lookup memory data via key.\n\n    Try to lookup via key directly (e.g. AddressEnum). On KeyError, if int, perform lookup via address.\n    When string, lookup via AddressEnum (using string). Otherwise, raise a KeyError.\n\n    :param key: key to lookup from data\n    :raises KeyError: cannot find key in data\n    \"\"\"\n    if isinstance(key, int):\n        return self.data[self.memclass.get(key)]\n    elif isinstance(key, str):\n        return self.data[self.memclass[key]]\n    return self.data[key]\n</code></pre>"},{"location":"api/types/#snirk.types.MemData.__init__","title":"__init__","text":"<pre><code>__init__(response=None)\n</code></pre> <p>Initialize memory data with optional parsing of gRPC response into data.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Optional[Union[MultiReadMemoryResponse, SingleReadMemoryResponse]]</code> <p>SNI multi read memory response to parse</p> <code>None</code> Source code in <code>snirk/types.py</code> <pre><code>def __init__(self, response: Optional[Union[pb.MultiReadMemoryResponse, pb.SingleReadMemoryResponse]] = None):\n    \"\"\"Initialize memory data with optional parsing of gRPC response into data.\n\n    :param response: SNI multi read memory response to parse\n    \"\"\"\n    self.data: dict[AddressEnum, int] = {}\n\n    if response:\n        self.parse(response)\n</code></pre>"},{"location":"api/types/#snirk.types.MemData.parse","title":"parse","text":"<pre><code>parse(response)\n</code></pre> <p>Parse gRPC response into data.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Union[pb.MultiReadMemoryResponse, pb.SingleReadMemoryResponse]</code> <p>SNI single/multi read memory response to parse</p> required Source code in <code>snirk/types.py</code> <pre><code>@singledispatchmethod\ndef parse(self, response):\n    \"\"\"Parse gRPC response into data.\n\n    :param response: SNI single/multi read memory response to parse\n    :type response: Union[pb.MultiReadMemoryResponse, pb.SingleReadMemoryResponse]\n    \"\"\"\n    raise NotImplementedError(f\"Cannot parse response: {response}\")\n</code></pre>"},{"location":"dev/","title":"Snirk Developer Docs","text":"<p>Development is intended to be done in a python3.11+ virtualenv with <code>poetry</code>.</p> <p>To get started, clone this repository, create and use a virtualenv, and install dependencies with <code>poetry</code>:</p> <pre><code>cd snirk\npython -m venv .venv\nsource .venv/bin/activate\npip install --upgrade pip\npoetry install\n</code></pre> <p>Tip</p> <p>You can use a different path for your venv if desired. It doesn't have to be <code>.venv</code>.</p>"},{"location":"dev/#development-and-contributions-overview","title":"development and contributions overview","text":"<p>Snirk uses several tools as part of the development stack.</p> <ul> <li><code>poetry</code>: packaging and dependency management</li> <li><code>black</code>: consistent code formatting</li> <li><code>flake8</code>: code error/quality checking</li> <li><code>isort</code>: consistent import sorter</li> <li><code>mypy</code>: type-checking</li> <li><code>mkdocs</code>: documentation generation</li> <li><code>pytest</code>: unit-testing</li> </ul> <p>All of the above tools are installed as developer dependencies when <code>poetry install</code> is run.</p> <p>Testing is intended to be able to be done locally, but tests are also run as part of a github workflow.</p> <p>Additional checks are run as part of a github workflow. This includes tools which are not <code>python</code> and thus not included in developer dependencies:</p> <ul> <li><code>markdownlint-cli</code>: error/quality checking of markdown files (e.g. documentation)</li> <li><code>shellcheck</code>: error/quality checking of shell files</li> </ul>"},{"location":"dev/#contribution-workflow","title":"contribution workflow","text":"<p>The recommended approach for making contributions follows:</p> <ul> <li>Assure all local tests work before making changes</li> <li>Make changes, run local tests, and iterate</li> <li>Commit changes to your own fork/branch</li> <li>Open a Pull Request (PR) on github.com from your fork/branch to snirk repo</li> <li>Verify that remote github workflow tests pass</li> <li>Mark PR as \"Ready for Review\"</li> <li>Receive review and iterate on any requested changes</li> <li>PR is merged by repo maintainers</li> </ul>"},{"location":"dev/#testing","title":"testing","text":"<p>The testing stragegy follows:</p> <ul> <li>Catch syntax issues and common \"gotchas\" via code formatters (<code>black</code>) and linters (<code>flake8</code>)</li> <li>Use <code>mypy</code> type-checking to catch many possible problems and boundary issues</li> <li>Unit testing via <code>pytest</code> for snirk-specific logic (e.g. filtering finding devices, checking device capabilities)</li> <li>Runnable <code>examples/</code>  to interact with actual SNI server and devices (e.g. Fx Pak Pro, Retroarch)</li> </ul>"},{"location":"dev/#local-testing","title":"local testing","text":"<p>An example <code>git</code> pre-commit hook script is included which can be used to automate local testing. If installed, it will be run before a commit can be made.</p> <p>To install the script, make a copy:</p> <pre><code>cp tools/pre-commit.sh .git/hooks/pre-commit\n</code></pre> <p>Note</p> <p>If your virtualenv is not \".venv\", then the copied pre-commit hook script will need to be modified to use your venv.</p> <p>This will run all testing tools which are part of the development stack. It will also run additional tools which are not included in the developer stack but are run as part of a github workflow, if they are available.</p> <p>Tip</p> <p>The pre-commit script can be run at any time, although it will run automatically when <code>git commit</code> is attempted. If you want to run it without committing you can just run <code>.git/hooks/pre-commit</code>.</p> <p>Example output of the pre-commit script:</p> <pre><code>black \u2714\nisort \u2714\nflake8 \u2714\nmypy \u2714\nmarkdownlint \u2714\nmkdocs \u2714\nshellcheck  \u2714\npytest (Python 3.11.7) \u2714\n</code></pre>"},{"location":"dev/#unit-testing","title":"unit testing","text":"<p>Most of the code in this repo involves wrapping communication to devices with SNI. As such, unit testing coverage via <code>pytest</code> is limited, requiring mocking of SNI gRPC calls. Currently, there is around 44% coverage. Tests are included in the <code>tests/</code> directory.</p> <p>The pytest-asyncio plugin for <code>pytest</code> is used which adds support for testing <code>asyncio</code> coroutines.</p>"},{"location":"dev/#running-examples","title":"running examples","text":"<p>There are example scripts included in the <code>examples/</code> directory (explained in usage).</p> <p>These can be run locally and are expected to work, but require actual devices (FxPak Pro, RetroArch, etc.), as well as running sni.</p> <p>As such, they are not really amendable to being run as part of a CI workflow, and instead will need to be checked manually when possible. This may mean some future changes would require repo maintainers or other code reviewers to manually check certain changes on PRs, if the code authors are unable to test.</p>"},{"location":"dev/#building","title":"building","text":"<p>Snirk can be built with <code>poetry</code>:</p> <pre><code>poetry build\n</code></pre> <p>This will create a sdist source tarball and wheel in the <code>dist/</code> directory. The wheel should be installable in another virtualenv and acts as the final artifact. These are what are uploaded to PyPI.</p>"},{"location":"dev/#building-and-serving-docs","title":"building and serving docs","text":"<p>Snirk uses <code>mkdocs</code> for building documentation.</p> <p>Docs can be built via:</p> <pre><code>mkdocs build\n</code></pre> <p>Additionally, a local docs server can be spun up and then tested in browser (default binds to <code>localhost:8000</code>):</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"dev/#additional-developer-details","title":"additional developer details","text":"<ul> <li>Release process</li> <li>SNI gRPC code generation</li> </ul>"},{"location":"dev/release-process/","title":"Snirk Release Process","text":"<p>Currently Snirk is manually released and published to PyPI by a repo maintainer.</p>"},{"location":"dev/release-process/#releasing","title":"releasing","text":"<p>The poetry-bumpversion plugin is used to update the version before publishing.</p> <p>After the version is updated, and the release is built, it can be published with poetry.</p> <p>The release workflow follows:</p> <ul> <li>Use <code>poetry version</code> to bump version</li> <li>Update <code>CHANGELOG.md</code></li> <li>Create and merge pull request off release branch</li> <li>Create Github Release / tag for new version</li> <li>Checkout updated <code>main</code> after PR merges</li> <li>Build with <code>poetry build</code></li> <li>Publish to PyPI with <code>poetry publish</code></li> </ul>"},{"location":"dev/release-process/#publishing-docs","title":"publishing docs","text":"<p>The GitHub Actions workflow at <code>.github/workflows/push-mkdocs-deploy.yaml</code> is run when a PR is merged to <code>main</code> which builds and publishes documentation to github pages using <code>mkdocs</code> via running the script at <code>tools/publish-mkdocs.sh</code>.</p>"},{"location":"dev/sni-grpc-codegen/","title":"SNI gRPC Code Generation","text":"<p>Snirk uses the gRPC interface provided by SNI. SNI includes proto files which describe the interfaces in protobuf (currently protobuf v3).</p> <p>These files are used to generate the SNI python library code in <code>snirk.sni</code>.</p>"},{"location":"dev/sni-grpc-codegen/#grpc-code-generation","title":"gRPC code generation","text":"<p>The gRPC and protobuf interfaces to SNI in the <code>snirk/sni/</code> directory were initially created using the <code>protoc</code> tool with <code>grpc-tools</code> python package from a checkout of the SNI repo (<code>alttpo/sni</code>).</p> <p>However, the generated files did not pass <code>flake8</code>/<code>mypy</code> analysis, and were modified to pass, and fix imports to match the package structure.</p> <p>Additionally, the git commit of <code>alttpo/sni</code> was found (via <code>git rev-parse HEAD</code>) and committed as <code>snirk/sni/version.txt</code>.</p> <p>A <code>tools/generate-sni-code.sh</code> script is included to checkout the <code>alttpo/sni</code> repo in a temporary directory at this commit and generate the code in <code>snirk/sni/</code>. In the event of updated proto files, this can be re-run to generate new gRPC code.</p>"}]}